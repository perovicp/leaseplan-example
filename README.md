# Leasing Demo Project - Products API test

This demo project is made in order to show possibilites of RESTapi integration tests via tools:
Serenity, Cucumber, RestAssured, Maven, Java, Git, Gitlab, Gitlab Pages.

![example workflow](https://github.com/perovicp/leaseplan-example/actions/workflows/maven.yml/badge.svg)
## The leasing demo project
This project has been done as SerenityRest demo for Project application

## Cucumber Run configuration for Cucumber Java (IntelliJ)
```sh
Mainclass: net.serenitybdd.cucumber.cli.Main
Glue: net.serenitybdd.cucumber.actors starter.stepdefinitions
```

### The project directory structure

src
  + main
  + test
    + java                        Test runners and configuration code
    + resources
      + features                    Feature files
     + search                  Feature file subdirectories 
             products.feature
```

```Gherkin
Feature: Search by keyword

Scenario Outline: Positive - Apple product response has at least one Apple Product
When GET request ist sent to <apple_endpoint>
Then results have at Least One Element of <product> Product type
  Examples:
    |apple_endpoint| product|
    |"apple"| Apple|
```

### Refactored
Refactored was almost everything, Products class, stepdefinitions, feature files, Readme,

### The Action Classes implementation.
A more imperative-style implementation using the Action Classes pattern can be found in the `action-classes` branch. The glue code in this version looks this this:

```java
    @When("GET request ist sent to {string}")
    public void getRequestIsSent(String endpoint) {
        SerenityRest.given().get(HOME + endpoint);
    }
```

## Executing the tests
By default, maven clean verify will execute all the API Integration tests
```json
$ mvn clean verify
```
The test results will be recorded in the `target` folder, then test report will be generated under:
`target\serenity\`

## Generating the reports
Since the Serenity reports contain aggregate information about all of the tests, they are not generated after each individual test (as this would be extremenly inefficient). Rather, The Full Serenity reports are generated by the `serenity-maven-plugin`. You can trigger this by running `mvn serenity:aggregate` from the command line or from your IDE.

They reports are also integrated into the Maven build process: the following code in the `pom.xml` file causes the reports to be generated automatically once all the tests have completed when you run `mvn verify`?

```
             <plugin>
                <groupId>net.serenity-bdd.maven.plugins</groupId>
                <artifactId>serenity-maven-plugin</artifactId>
                <version>${serenity.maven.version}</version>
                <configuration>
                    <tags>${tags}</tags>
                </configuration>
                <executions>
                    <execution>
                        <id>serenity-reports</id>
                        <phase>post-integration-test</phase>
                        <goals>
                            <goal>aggregate</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
```
